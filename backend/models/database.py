"""Database models and connection for BTC 5-min trading bot."""
from datetime import datetime
from typing import Optional
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Boolean, JSON, text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy import inspect
import enum

from backend.config import settings

engine = create_engine(
    settings.DATABASE_URL,
    connect_args={"check_same_thread": False} if "sqlite" in settings.DATABASE_URL else {}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()


class Trade(Base):
    """Simulated trades for tracking P&L."""
    __tablename__ = "trades"

    id = Column(Integer, primary_key=True, index=True)
    signal_id = Column(Integer, index=True)
    market_ticker = Column(String, index=True)
    platform = Column(String)
    event_slug = Column(String, nullable=True)

    # Trade details
    direction = Column(String)  # "up" or "down"
    entry_price = Column(Float)
    size = Column(Float)
    timestamp = Column(DateTime, default=datetime.utcnow)

    # Settlement
    settled = Column(Boolean, default=False)
    settlement_time = Column(DateTime, nullable=True)
    settlement_value = Column(Float, nullable=True)  # 1.0=Up won, 0.0=Down won
    result = Column(String, default="pending")  # pending, win, loss
    pnl = Column(Float, nullable=True)

    # Model performance tracking
    model_probability = Column(Float)
    market_price_at_entry = Column(Float)
    edge_at_entry = Column(Float)


class BtcPriceSnapshot(Base):
    """Cached BTC prices for momentum calculation."""
    __tablename__ = "btc_price_snapshots"

    id = Column(Integer, primary_key=True, index=True)
    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
    price = Column(Float)
    source = Column(String, default="coingecko")


class BotState(Base):
    """Bot state and statistics."""
    __tablename__ = "bot_state"

    id = Column(Integer, primary_key=True)
    bankroll = Column(Float, default=10000.0)
    total_trades = Column(Integer, default=0)
    winning_trades = Column(Integer, default=0)
    total_pnl = Column(Float, default=0.0)
    last_run = Column(DateTime, nullable=True)
    is_running = Column(Boolean, default=False)


class Signal(Base):
    """Trading signals generated by the bot."""
    __tablename__ = "signals"

    id = Column(Integer, primary_key=True, index=True)
    market_ticker = Column(String, index=True)
    platform = Column(String)
    timestamp = Column(DateTime, default=datetime.utcnow, index=True)

    direction = Column(String)
    model_probability = Column(Float)
    market_price = Column(Float)
    edge = Column(Float)
    confidence = Column(Float)

    kelly_fraction = Column(Float)
    suggested_size = Column(Float)

    sources = Column(JSON)
    reasoning = Column(String)

    executed = Column(Boolean, default=False)

    # Calibration tracking — filled after settlement
    actual_outcome = Column(String, nullable=True)    # "up" or "down" — actual market result
    outcome_correct = Column(Boolean, nullable=True)   # did our direction prediction match?
    settlement_value = Column(Float, nullable=True)     # 1.0=UP won, 0.0=DOWN won
    settled_at = Column(DateTime, nullable=True)        # when we recorded the outcome


class AILog(Base):
    """Log of all AI API calls."""
    __tablename__ = "ai_logs"

    id = Column(Integer, primary_key=True, index=True)
    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
    provider = Column(String, index=True)
    model = Column(String)

    prompt = Column(String)
    response = Column(String)
    call_type = Column(String, index=True)

    latency_ms = Column(Float)
    tokens_used = Column(Integer)
    cost_usd = Column(Float)

    related_market = Column(String, nullable=True)
    success = Column(Boolean, default=True)
    error = Column(String, nullable=True)


class ScanLog(Base):
    """Log of each market scan run."""
    __tablename__ = "scan_logs"

    id = Column(Integer, primary_key=True, index=True)
    run_id = Column(String, unique=True, index=True)
    started_at = Column(DateTime, default=datetime.utcnow)
    completed_at = Column(DateTime, nullable=True)

    categories_scanned = Column(JSON)
    platforms_scanned = Column(JSON)

    markets_found = Column(Integer, default=0)
    signals_generated = Column(Integer, default=0)
    trades_executed = Column(Integer, default=0)

    ai_calls_made = Column(Integer, default=0)
    ai_cost_usd = Column(Float, default=0.0)

    success = Column(Boolean, default=True)
    error = Column(String, nullable=True)


def init_db():
    """Initialize database tables."""
    Base.metadata.create_all(bind=engine)
    ensure_schema()


def ensure_schema():
    """Ensure newer schema fields exist even if migration wasn't run."""
    inspector = inspect(engine)
    try:
        columns = [col["name"] for col in inspector.get_columns("trades")]
    except Exception:
        return

    if "event_slug" not in columns:
        stmt = "ALTER TABLE trades ADD COLUMN event_slug VARCHAR"
        if engine.dialect.name not in ("sqlite", "mysql"):
            stmt = "ALTER TABLE trades ADD COLUMN IF NOT EXISTS event_slug VARCHAR"

        with engine.connect() as conn:
            with conn.begin():
                conn.execute(text(stmt))

    # Add calibration columns to signals table
    try:
        signal_columns = [col["name"] for col in inspector.get_columns("signals")]
    except Exception:
        signal_columns = []

    if signal_columns:
        with engine.connect() as conn:
            for col, coltype in [
                ("actual_outcome", "TEXT"),
                ("outcome_correct", "BOOLEAN"),
                ("settlement_value", "FLOAT"),
                ("settled_at", "DATETIME"),
            ]:
                if col not in signal_columns:
                    try:
                        with conn.begin():
                            conn.execute(text(f"ALTER TABLE signals ADD COLUMN {col} {coltype}"))
                    except Exception:
                        pass  # column already exists


def get_db():
    """Get database session."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
